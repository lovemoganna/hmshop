31、如何权衡是使用无序的数组还是有序的数组？
有序数组的最大的好处在于查找的时间复杂度是O(log n)，
而无序数组是O(n)。

有序数组的缺点是插入操作的时间复杂度是O(n),
因为值大的元素需要往后移动来给新元素腾出位置。
相反，无序数组的插入时间复杂度是常量O(1).

32、Java集合类框架的最佳实践有哪些？

根据应用的需要正确选择要使用的集合的类型对性能非常重要。


for example:
假如元素的大小是固定的，而且能事先知道，我们就应该使用Array而不是用ArrayList。

有些集合类允许指定初始容量。
因此，如果我们能估算出存储的元素的数目，
我们可以设置初始容量，
来避免计算hash值或者是扩容。

为了类型安全，可读性和健壮性的原因总是要使用泛型。
同时使用泛型还可以避免运行时的ClassCastException。

使用JDK提供的不变类（immutable class）作为Map的键可以避免为我们
自己的类实现hashCode()和equals（）方法。

编程的时候接口优于实现。

底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null.

33、Enumeration接口和Iterator接口的区别有哪些？
Enumeration速度是Iterator的2倍，同时占用更少的内存。

但是，Iterator远远比Enumeration安全，
因为其他线程不能够修改
正在被Iterator遍历的集合里面的对象。

同时,Iterator允许调用者删除底层集合里面的元素
，这对Enumeration来说是不可能的。

34、HashSet和TreeSet有什么区别？
HashSet是由一个hash表来实现的，因此，
他的元素是无序的。
add(),remove(),contains()方法的时间复杂度是O(1).

另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。
因此，add()，remove(),contains()方法的时间复杂度是O(logn).

垃圾收集器（Garbage Collectors）

35、Java中垃圾回收有什么目的？什么时候进行垃圾回收？
垃圾回收的目的是
识别并且丢弃应用不再使用的对象
，来释放和重用资源。

36、System.gc()和Runtime,gc()会做什么事情？
这两个方法用来提示JVM要进行垃圾回收。
但是，立即开始还是延迟进行垃圾回收是取决以JVM的。

37、finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
在释放对象占用的内存之前，垃圾收集器会调用对象的finalze()方法。
一般建议该方法中释放对象持有的资源。

38、如果对象的引用变量为null,垃圾回收器是否会立即释放对象占用的内存？
不会，在下一个垃圾回收周期中，这个对象是可被回收的。

39、Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen sapce)？
JVM 的堆是运行时数据区，所有的类的实例和数组都是在堆上分配内存。
它在JVM启动的时候被创建。
对象所占的堆内存是由自动内存管理系统
也就是来及收集器回收。

堆内存是由存活和死亡的对象组成的。
存活的对象是应用可以访问的，不会被垃圾回收。
死亡的对象是应用不可访问
且尚且还没被垃圾回收器收掉的对象。
一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。

40、串行(serial)收集器和吞吐量收集器(throughput)的区别是什么？
吞吐量收集器使用并行版本的新生代垃圾收集器，
它用于中等规模和大规模数据的应用程序。

而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。
